{
    "name": "neo4j-sink",
    "config": {
        "name" : "neo4j-sink",
        "connector.class" : "streams.kafka.connect.sink.Neo4jSinkConnector",
        "tasks.max" : "1",
        "topics" : "departments, specialities, department_speciality, groups, courses, group_course, classes, schedule, students",
        "key.converter": "io.confluent.connect.avro.AvroConverter",
        "key.converter.schema.registry.url": "http://schema-registry:8081",
        "value.converter": "io.confluent.connect.avro.AvroConverter",
        "value.converter.schema.registry.url": "http://schema-registry:8081",
        "errors.retry.timeout": "-1",
        "errors.retry.delay.max.ms": "1000",
        "errors.tolerance": "all",
        "errors.log.enable": true,
        "errors.log.include.messages": true,
        "neo4j.batch.parallelize": false,
        "neo4j.server.uri" : "bolt://neo4j:7687",
        "neo4j.topic.cypher.departments" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (d:Department{id: event.after.id}) SET d += {code: event.after.code, title: event.after.title}', event.op = 'd', 'MATCH (d:Department{id: event.before.id}) DETACH DELETE d', event.op = 'u', 'MATCH (d:Department{id: event.before.id}) SET d += {code: event.after.code, title: event.after.title}'], '', {event: event}) YIELD value as d RETURN d",
        "neo4j.topic.cypher.specialities" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (s:Speciality{id: event.after.id}) SET s += {code: event.after.code, title: event.after.title}', event.op = 'd', 'MATCH (s:Speciality{id: event.before.id}) DETACH DELETE s', event.op = 'u', 'MATCH (s:Speciality{id: event.before.id}) SET s += {code: event.after.code, title: event.after.title}'], '', {event: event}) YIELD value as department RETURN department",
        "neo4j.topic.cypher.department_speciality" : "CALL apoc.do.case([event.op = 'c' OR event.op = 'c', 'MERGE (d:Department {id: event.after.department_id}) MERGE (s:Speciality {id: event.after.speciality_id}) MERGE (d)-[:HAS_SPECIALITY]->(s)', event.op = 'd', 'MATCH (d:Department {id: event.before.department_id})-[r:HAS_SPECIALITY]->(s:Speciality {id: event.before.speciality_id}) DELETE r', event.op = 'u', 'MATCH (d:Department {id: event.before.department_id})-[r:HAS_SPECIALITY]->(s:Speciality {id: event.before.speciality_id}) DELETE r MATCH (d2:Department {id: event.after.department_id}) MATCH (s2:Speciality {id: event.after.speciality_id}) MERGE (d2)-[:HAS_SPECIALITY]->(s2)'], '', {event: event}) YIELD value as department RETURN department",
        "neo4j.topic.cypher.groups" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (g:Group {id: event.after.id}) ON CREATE SET g += {title: event.after.title} MERGE (d:Department {id: event.after.department_id}) MERGE (s:Speciality {id: event.after.speciality_id}) MERGE (d)-[:OFFERS_GROUP]->(g)-[:HAS_SPECIALITY]->(s)', event.op = 'd', 'MATCH (g:Group{id: event.before.id}) DETACH DELETE g', event.op = 'u', 'MATCH (g:Group{id: event.before.id}) MATCH (d:Department {id: event.before.department_id}) MATCH (s:Speciality {id: event.before.speciality_id}) MATCH (d)-[dg:OFFERS_GROUP]->(g)-[gs:HAS_SPECIALITY]->(s) DELETE dg DELETE gs MERGE (dN:Department {id: event.after.department_id}) MERGE (sN:Speciality {id: event.after.speciality_id}) MERGE (dN)-[:OFFERS_GROUP]->(g)-[:HAS_SPECIALITY]->(sN) SET g += {title: event.after.title}'], '', {event: event}) YIELD value as g RETURN g",
        "neo4j.topic.cypher.courses" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (c:Course {id: event.after.id}) MERGE (d:Department {id: event.after.department_id}) MERGE (d)-[:HAS_COURSE]->(c) SET c += {title: event.after.title, department_tag: event.after.department_tag}', event.op = 'd', 'MATCH (c:Course{id: event.before.id}) DETACH DELETE c', event.op = 'u', 'MATCH (c:Course{id: event.before.id}) MATCH (d:Department {id: event.before.department_id}) MATCH (d)-[r:HAS_COURSE]->(c) DELETE r MERGE (dN:Department {id: event.after.department_id}) MERGE (dN)-[r:HAS_COURSE]->(c) SET c += {title: event.after.title, department_tag: event.after.department_tag}'], '', {event: event}) YIELD value as c RETURN c",
        "neo4j.topic.cypher.group_course" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (g:Group {id: event.after.group_id}) MERGE (c:Course {id: event.after.course_id}) MERGE (g)-[:STUDY_COURSE]->(c)', event.op = 'd', 'MATCH (g:Group {id: event.before.group_id})-[r:STUDY_COURSE]->(c:Course {id: event.before.course_id}) DELETE r', event.op = 'u', 'MATCH (g:Group {id: event.before.group_id})-[r:STUDY_COURSE]->(c:Course {id: event.before.course_id}) DELETE r MATCH (gN:Group {id: event.after.group_id}) MATCH (cN:Course {id: event.after.course_id}) MERGE (gN)-[:STUDY_COURSE]->(cN)'], '', {event: event}) YIELD value as g RETURN g",
        "neo4j.topic.cypher.classes" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (cl:Class {id: event.after.id}) MERGE (c:Course {id: event.after.course_id}) MERGE (c)-[:HAS_CLASS]->(cl) SET cl += {title: event.after.title, type_id: event.after.type_id, equipment: event.after.equipment}', event.op = 'd', 'MATCH (cl:Class{id: event.before.id}) DETACH DELETE cl', event.op = 'u', 'MATCH (cl:Class{id: event.before.id}) MATCH (c:Course {id: event.before.course_id}) MATCH (c)-[r:HAS_CLASS]->(cl) DELETE r MATCH (cN:Course {id: event.after.course_id}) MERGE (cN)-[:HAS_CLASS]->(cl) SET cl += {title: event.after.title, type_id: event.after.type_id, equipment: event.after.equipment}'], '', {event: event}) YIELD value as cl RETURN cl",
        "neo4j.topic.cypher.schedule" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (sc:Schedule {id: event.after.id}) MERGE (cl:Class {id: event.after.class_id}) MERGE (g:Group {id: event.after.group_id}) MERGE (cl)<-[:REFERS_TO_CLASS]-(sc)-[:REFERS_TO_GROUP]->(g) SET sc += {date: event.after.date, pair_number: event.after.pair_number}', event.op = 'd', 'MATCH (sh:Schedule{id: event.before.id}) DETACH DELETE sh', event.op = 'u', 'MATCH (sc:Schedule{id: event.before.id}) MATCH (cl:Class {id: event.before.class_id}) MATCH (g:Group {id: event.before.group_id}) MATCH (cl)<-[clsc:REFERS_TO_CLASS]-(sc)-[scg:REFERS_TO_GROUP]->(g) DELETE clsc DELETE scg MERGE (clN:Class {id: event.after.class_id}) MERGE (gN:Group {id: event.after.group_id}) MERGE (clN)<-[:REFERS_TO_CLASS]-(sc)-[:REFERS_TO_GROUP]->(gN) SET sc += {date: event.after.date, pair_number: event.after.pair_number}'], '', {event: event}) YIELD value as sc RETURN sc",
        "neo4j.topic.cypher.students" : "CALL apoc.do.case([event.op = 'r' OR event.op = 'c', 'MERGE (s:Student {id: event.after.id}) MERGE (g:Group {id: event.after.group_id}) MERGE (s)-[:STUDY_IN]->(g) SET s += {fullname: event.after.fullname, code: event.after.code}', event.op = 'd', 'MATCH (s:Student{id: event.before.id}) DETACH DELETE s', event.op = 'u', 'MATCH (s:Student{id: event.before.id}) MATCH (g:Group {id: event.before.group_id}) MATCH (s)-[r:STUDY_IN]->(g) DELETE r MERGE (gN:Group {id: event.after.group_id}) MERGE (s)-[:STUDY_IN]->(gN) SET s += {fullname: event.after.fullname, code: event.after.code}'], '', {event: event}) YIELD value as s RETURN s"
       
  }
}